#!/usr/bin/env python
from sys import argv
from SamRow import SamRow
from parsers import fasta_parser,fastq_parser
import deepdish as dd


def search_bw(suffix_array, text, pat, O, C):
    m = len(pat)  # lenght of the pattern
    n = len(text + '$')  # length of the text

    l = 0
    r = n - 1
    i = m - 1

    while (i >= 0 and l <= r):

        c = pat[i]

        if l - 1 < 0:  # dealing with negative indexes
            try:
                l = C[c] + 1 # here trying to deal with letters that are not present in the text
            except:

                return(None)
        else:
            l = C[c] + O[c][l - 1] + 1

        r = C[c] + O[c][r]

        i = i - 1

    if i < 0 and l <= r:
        zero_indexed = suffix_array[l:r + 1]
        one_indexed = [x + 1 for x in zero_indexed]
        return(sorted(one_indexed)) # sorting just to look exact as required
    else:
        zero_indexed = suffix_array[l:r + 1]
        return(sorted(zero_indexed))


# Reading the preprocessed files:
O_table = dd.io.load('../../evaluation/O_table.h5')
C_table = dd.io.load('../../evaluation/C_table.h5')
suffix_array = dd.io.load('../../evaluation/suffix_array.h5')

# Reading data:
nameOfFile = argv[0] #not used
d_argument = argv[1] # not used
d_argument_param = argv[2] # not used
dictFasta = fasta_parser(argv[3])
dictFastq = fastq_parser(argv[4])

refName = dictFasta.keys()[0]
text = dictFasta[refName]
keys = dictFastq.keys()

for key in keys:
    matches = search_bw(suffix_array, text, dictFastq[key][0], O_table, C_table)
    for match in matches:
        print match
        if match != []:

            # TODO: PRODUCE ACTUAL CIGAR!
            samRow = SamRow(refName, key, match, str(len(dictFastq[key][0])) + "M", dictFastq[key][0], dictFastq[key][1])
            samRow.writeSamRow("mybw_mapper.sam")
