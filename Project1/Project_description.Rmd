---
title: "Project 1: Genome Scale algorithms"
author: "Maria, Mateo and Jacob"
date: "2/20/2018"
output:
  pdf_document:
  variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)

```


```{r Setup, warning=FALSE}

# Import Naive
df_Naive = read.csv("Test ExactSubstring_Naive.csv", header = FALSE)

colnames(df_Naive) = c("Function", "Time", "n", "m", "z", "RunName")

df_Naive$RunName = factor(x = df_Naive$RunName)
df_Naive$Function = factor(x = df_Naive$Function)

# Import KMP
df_KMP = read.csv("Test ExactSubstring_KMP.csv", header = FALSE)

colnames(df_KMP) = c("Function", "Time", "n", "m", "z", "RunName")

df_KMP$RunName = factor(x = df_KMP$RunName)
df_KMP$Function = factor(x = df_KMP$Function)

```

## Program description

The programs are implemented in Python, we had no unsolved issues implementing the algorithms.
Execution of the program on commandline takes the form:
  python search-naive.py [text-filename] [str-pattern]
  python search-kmp.py [text-filename] [str-pattern]
and the output is directly to the console.

## Test of search-naive
We used the data provided for testing which outputs the following results:
python search-naive.py banana.txt ana
2 4

python search-naive.py mississippi.txt ss
3 6
 
python search-naive.py walrus-and-carpenter.txt Walrus
5 660 915 1059 1773 1951 2326 2617 2855 3050

python search-naive.py ancient-mariner.txt Albatross
2876 2991 3272 3443 5586 6899 14180 19139 23729

## Test of search-kmp
python search-kmp.py banana.txt ana
2 4

python search-kmp.py mississippi.txt ss
3 6
 
python search-kmp.py walrus-and-carpenter.txt Walrus
5 660 915 1059 1773 1951 2326 2617 2855 3050

python search-kmp.py ancient-mariner.txt Albatross
2876 2991 3272 3443 5586 6899 14180 19139 23729

```{r Correctness1, warning=FALSE}


```

## Runtime - Naive

The implementation of the naive algorithm runs in O( n * m ) time. With best case input at 0 occurrences of pattern in the text, and worst case is constant matching to keep the inner loop active ( m = n^0.5 ).

The following plot shows the runtime / regression of the Y axis and regression on X axis. Where the regression is: Time ~ n + m.
It clearly shows that the runtime is more than linear.

```{r Naive1, warning=FALSE}

fit_naive = lm( data = df_Naive, formula = Time ~ m + n)

ggplot( data = df_Naive ) +
  geom_line( 
    aes( 
      y = Time / ( m * fit_naive$coefficients[2] + fit_naive$coefficients[3] * n ), 
      x = m * fit_naive$coefficients[2] + fit_naive$coefficients[3] * n + fit_naive$coefficients[1] 
    ), 
    color = "#000000", alpha = 0.9 
  ) 

```

The following plot shows the runtime / regression of the Y axis and regression on X axis. Where the regression is: Time ~ n * m.
This plot flatlines around y = 1, with random spikes of longer runtime which can be explained by background resource usage.

```{r Naive2, warning=FALSE}

fit_naive_poly = glm( data = df_Naive, formula = Time ~ n * m )
fit_naive_poly
inc = fit_naive_poly$coefficients[1]
c_n = fit_naive_poly$coefficients[2]
c_m = fit_naive_poly$coefficients[3]
c_nm = fit_naive_poly$coefficients[4]
Interaction_Regression = inc + c_n * df_Naive$n + c_m * df_Naive$m + df_Naive$n * df_Naive$m * c_nm
Interaction_Regression = 0 + c_n * df_Naive$n + 0 * df_Naive$m + df_Naive$n * df_Naive$m * c_nm

ggplot(  ) +
  geom_line( 
    aes( 
      y = df_Naive$Time / Interaction_Regression, 
      x = Interaction_Regression
    )
  ) + xlim(0.001, 0.03) + ylim(0, 8)


```

## Runtime - KMP

The implementation of the KMP algorithm runs in O( n + m ) time. The best case is a pattern with a simple failure function (all pointing to the base case), where the worst case keeps the inner loops busy by jumping with failures.
The following plot shows the runtime / regression of the Y axis and regression on X axis. Where the regression is: Time ~ n + m.
This plot flatlines around y = 1, with random spikes of longer runtime which can be explained by background resource usage.


```{r KMP,warning=FALSE}

fit_kmp = glm( data = df_KMP, formula = Time ~ n + m )
inc = fit_kmp$coefficients[1]
c_m = fit_kmp$coefficients[3]
c_n = fit_kmp$coefficients[2]
kmp_Regression = inc + c_n * df_KMP$n + c_m * df_KMP$m
kmp_Regression = 0 + c_n * df_KMP$n + c_m * df_KMP$m

ggplot(  ) +
  geom_line( 
    aes( 
      y = df_KMP$Time / kmp_Regression, 
      x = kmp_Regression
    )
  ) + xlim(0.001, 0.0085) + ylim(0.5, 5)

```

## Testdata and Number of occurrences

Tests of runtime was done the same way for both algorithms.
First varying m and keeping n the same.
Second keepoing m the same and varying n.
Third by varying both n and m together.

The number of occurrences of the pattern in the string has no significant impact on the naive implementation.
Here is the p-value of an ANOVA of the addition to the regression.

```{r Anova-naive,warning=FALSE}

fit_naive = lm( data = df_Naive, formula = Time ~ n + m )
fit_naive_z = lm( data = df_Naive, formula = Time ~ n + m + z )

an_naive = anova(fit_naive, fit_naive_z)
an_naive$`Pr(>F)`

```

The number of occurrences of the pattern in the string has no significant impact on the KMP implementation.
Here is the p-value of an ANOVA of the addition to the regression.

```{r Anova-KMP,warning=FALSE}

fit_kmp = lm( data = df_KMP, formula = Time ~ n + m )
fit_kmp_z = lm( data = df_KMP, formula = Time ~ n + m + z )

an_kmp = anova(fit_kmp, fit_kmp_z)
an_kmp$`Pr(>F)`

```

## Measuring time in a different way
```{r}
library(dplyr)
library(ggpubr)
setwd('/Users/PM/Dropbox/Genome_scale_algorithms/Genome_scale_algorithms/Project1')
df_Naive = read.csv("Test ExactSubstring_Naive.csv", header = FALSE)
df_KMP = read.csv("Test ExactSubstring_KMP.csv", header = FALSE)
colnames(df_Naive) = c("Function", "Time", "n", "m", "z", "RunName")
colnames(df_KMP) = c("Function", "Time", "n", "m", "z", "RunName")

dat_kmp = df_KMP 
dat_naive = df_Naive
ploting <- function(dat_naive, dat_kmp){
      dat_naive <- dat_naive %>%
            mutate(type = "Naive")
    
      dat_kmp <- dat_kmp %>%
            mutate(type = "KMP")
      
      all <- rbind(dat_kmp, dat_naive)
      colnames(all) = c("Function", "Time", "n", "m", "z", "RunName", "Type")
      
      constant_n <- all %>%
              filter(n == 10000)
      
      constant_m <- all %>%
              filter(m == 10)
      return(list(constant_n, constant_m))
} 

fig <- ploting(df_Naive, df_KMP)

      #a <- qplot(y = Constant_n$Time/Constant_n$m, x = Constant_n$m) + ylim(0,0.001)
      #b <- qplot(y = Constant_m$Time/Constant_m$n, x = Constant_m$n) + ylim(0,2.5*10^-6)

      a <- ggplot(data = fig[[1]]) + 
        geom_point(mapping = aes(y = Time/m, x = m, color = Type)) + theme_bw() +  scale_y_log10() 
      
      b <- ggplot(data = fig[[2]]) + theme_bw() +
        geom_point(mapping = aes(y = Time/n, x = n, color = Type))  + scale_y_log10() 
      c <- ggplot(data = fig[[2]]) +
        geom_point(mapping = aes(y = Time*10^4, x = n, color = Type)) + geom_smooth(method = "lm", mapping = aes(y = Time*10^4, x = n)) + theme_bw()
      
      d <- ggplot(data = fig[[1]]) + 
        geom_point(mapping = aes(y = Time/m, x = m, color = Type)) + theme_bw() +  scale_y_log10() 
      
      e <- ggplot(data = fig[[2]]) + theme_bw() +
        geom_point(mapping = aes(y = Time/n, x = n, color = Type))  + scale_y_log10() 
      
      f <- ggplot(data = fig[[2]]) +
      geom_point(mapping = aes(y = Time*10^4, x = n, color = Type)) + geom_smooth(method = "lm",mapping = aes(y = Time*10^4, x = n)) + theme_bw()

ggarrange(a, b, c, d, e, f,
      labels = c('A', 'B', 'C', 'D', 'E', 'F'),
      ncol = 2, nrow = 3)




```
